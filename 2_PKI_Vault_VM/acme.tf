/*
Certificate Management using Vault PKI ACME
This configuration uses HashiCorp Vault PKI's ACME implementation
to generate TLS certificates

Benefits:
- Uses internal PKI infrastructure (Vault)
- Certificates issued by your own CA
- Full control over certificate policies

Note: Requires Vault PKI ACME to be configured (see vault_pki.tf)
*/

/*
Generate a private key for CA certificate
2048-bit RSA is the standard for TLS/SSL certificates
*/
resource "tls_private_key" "ca" {
  algorithm = "RSA"
  rsa_bits  = 2048
}


# Get AWS Route53 hosted zone information
data "aws_route53_zone" "env_dns_zone" {
  name         = var.hosted_dns_zone # Domain name (e.g., "example.com")
  private_zone = false               # Public hosted zone
}

locals {
  # Domain name from Route53 hosted zone (removes trailing dot if present)
  domain = trimsuffix(data.aws_route53_zone.env_dns_zone.name, ".")

  # Sanitize region name for use in domain names (remove spaces, convert to lowercase)
  region_sanitized = lower(replace(var.aws_region, " ", "-"))
}

/*
ACME provider configuration for Vault PKI
Uses HashiCorp Vault PKI as the ACME server instead of Let's Encrypt
*/
provider "acme" {
  # Use Vault PKI ACME directory (with namespace in URL)
  server_url = "${data.hcp_vault_cluster.example.vault_public_endpoint_url}/v1/admin/pki_int/acme/directory"
}

/*
Generate private key for ACME account registration
This key is used to authenticate with Vault ACME
*/
resource "tls_private_key" "private_key" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

/*
Register account with Vault ACME
Uses External Account Binding (EAB) credentials from Vault
*/
resource "acme_registration" "registration" {
  account_key_pem = tls_private_key.private_key.private_key_pem
  email_address   = "admin@${local.domain}"

  # EAB is required for Vault PKI ACME
  external_account_binding {
    key_id      = vault_generic_endpoint.acme_eab_terraform_server.write_data["id"]
    hmac_base64 = vault_generic_endpoint.acme_eab_terraform_server.write_data["key"]
  }

  # Prevent errors during destroy when Vault PKI is deleted first
  lifecycle {
    create_before_destroy = false
  }

  depends_on = [
    vault_generic_endpoint.acme_eab_terraform_server,
    vault_pki_secret_backend_config_acme.intermediate_acme
  ]
}

resource "random_string" "random_name" {
  length  = 4
  upper   = false
  lower   = true
  numeric = false
  special = false
}

/*
Request certificate from Vault PKI using ACME
Note: Vault ACME with sign-verbatim doesn't require challenge validation
but you can use HTTP-01 or DNS-01 if needed
*/
resource "acme_certificate" "certificate" {
  account_key_pem = acme_registration.registration.account_key_pem
  common_name     = "terraform-acme-${random_string.random_name.result}.${local.domain}"

  # Optional: Add wildcard certificate
  # subject_alternative_names = ["*.${local.domain}"]
  /*  
  http_challenge {
  # Using HTTP-01 challenge (can also use DNS-01 with route53)
    # This would require the domain to be accessible via HTTP
    # Alternatively, use dns_challenge if the server isn't publicly accessible yet
  }
*/

  # Alternative: Use DNS challenge with Route53
  dns_challenge {
    provider = "route53"
    config = {
      AWS_REGION = var.aws_region
    }
  }

  # Prevent errors during destroy when Vault PKI is deleted first
  lifecycle {
    create_before_destroy = false
  }

  depends_on = [
    acme_registration.registration,
    vault_pki_secret_backend_config_acme.intermediate_acme
  ]
}


/*
Certificate data extraction from Acme certificate resource
Provides fallback to empty strings if certificate generation fails
*/
locals {
  # Extract certificate components from ACME certificate resource
  vault_cert = try(acme_certificate.certificate.certificate_pem, "") # Public certificate
  vault_ca   = try(acme_certificate.certificate.issuer_pem, "")      # CA certificate chain
  vault_key  = try(acme_certificate.certificate.private_key_pem, "") # Private key
}

/*
TLS data formatted for Kubernetes secrets
Base64 encoding is handled by Kubernetes, so we provide raw PEM data
*/
locals {
  tls_data = {
    ca   = base64encode(local.vault_ca)   # CA certificate (base64 encoded)
    cert = base64encode(local.vault_cert) # Server certificate (base64 encoded)
    pk   = base64encode(local.vault_key)  # Private key (base64 encoded)
  }
}

/*
JSON-encoded secret data for use in Helm templates
Can be used directly in Kubernetes secret resources
*/
locals {
  secret = jsonencode(local.tls_data)
}

/*
AWS Secrets Manager - Store TLS Certificate (Public Certificate)
*/
resource "aws_secretsmanager_secret" "vault_tls_certificate" {
  name                    = "terraform-acme-${random_string.random_name.result}"
  description             = "TLS public certificate generated by Terraform ACME provider using Vault PKI"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name      = "terraform-acme-certificate"
    Purpose   = "terraform-acme-tls-cert"
    ManagedBy = "Terraform"
  }
}

resource "aws_secretsmanager_secret_version" "vault_tls_certificate" {
  secret_id = aws_secretsmanager_secret.vault_tls_certificate.id
  secret_string = jsonencode({
    certificate = local.vault_cert # Public certificate (PEM format)
    domain      = local.domain
    created_at  = timestamp()
  })

  depends_on = [acme_certificate.certificate]
}

/*
AWS Secrets Manager - Store TLS Private Key
*/
resource "aws_secretsmanager_secret" "vault_tls_private_key" {
  name                    = "vault-tls-private-key-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS private key generated by Terraform ACME provider using Vault PKI"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name      = "terraform-acme-private-key"
    Purpose   = "terraform-acme-tls-key"
    ManagedBy = "Terraform"
  }
}

resource "aws_secretsmanager_secret_version" "vault_tls_private_key" {
  secret_id = aws_secretsmanager_secret.vault_tls_private_key.id
  secret_string = jsonencode({
    private_key = local.vault_key # Private key (PEM format)
    domain      = local.domain
    created_at  = timestamp()
  })

  depends_on = [acme_certificate.certificate]
}

/*
AWS Secrets Manager - Store TLS CA Certificate
*/
resource "aws_secretsmanager_secret" "vault_tls_ca_certificate" {
  name                    = "vault-tls-ca-certificate-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS CA certificate chain generated by Terraform ACME provider using Vault PKI"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name      = "terraform-acme-ca-certificate"
    Purpose   = "terraform-acme-tls-ca"
    ManagedBy = "Terraform"
  }
}

resource "aws_secretsmanager_secret_version" "vault_tls_ca_certificate" {
  secret_id = aws_secretsmanager_secret.vault_tls_ca_certificate.id
  secret_string = jsonencode({
    ca_certificate = local.vault_ca # CA certificate chain (PEM format)
    domain         = local.domain
    created_at     = timestamp()
  })

  depends_on = [acme_certificate.certificate]
}
